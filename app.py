import os, time, random, requests, sqlite3
from flask import Flask, render_template, request, redirect, url_for, flash, session, g
from werkzeug.security import generate_password_hash, check_password_hash
import math
from google import genai
import json

# Get key from environmental GEMINI_API_KEY
client = genai.Client()

# Optional Databricks
USE_DATABRICKS = os.getenv("USE_DATABRICKS", "false").lower() == "true"
if USE_DATABRICKS:
    from databricks import sql

app = Flask(__name__)
app.secret_key = os.getenv("FLASK_SECRET_KEY", "dev_only__change_me")
app_name = "PathWise"

# --- External APIs
SCORECARD_KEY  = os.getenv("SCORECARD_API_KEY")
SCORECARD_BASE = "https://api.data.gov/ed/collegescorecard/v1/schools"

# --- Local SQLite fallback (dev)
SQLITE_DB = "database.db"

# --- Databricks catalog/schema (defaults)
DB_CATALOG = os.getenv("DB_CATALOG", "hive_metastore")
DB_SCHEMA  = os.getenv("DB_SCHEMA",  "default")

# Unified table names (fully qualified when using Databricks)
TB_USERS   = f"{DB_CATALOG}.{DB_SCHEMA}.users"   if USE_DATABRICKS else "users"
TB_SCHOOLS = f"{DB_CATALOG}.{DB_SCHEMA}.schools" if USE_DATABRICKS else "schools"

# ========== DB LAYER (ONE WAY TO TALK TO EITHER BACKEND) ==========
def get_conn():
    """Returns a connection object (Databricks SQL or SQLite)."""
    if "conn" in g:
        return g.conn

    if USE_DATABRICKS:
        g.conn = sql.connect(
            server_hostname=os.getenv("DATABRICKS_SERVER_HOSTNAME"),
            http_path=os.getenv("DATABRICKS_HTTP_PATH"),
            access_token=os.getenv("DATABRICKS_TOKEN"),
        )
    else:
        g.conn = sqlite3.connect(SQLITE_DB)
        g.conn.row_factory = sqlite3.Row  # keeps dev happy too
    return g.conn

def exec_nonquery(sql_text: str, params: dict | None = None):
    """Execute INSERT/UPDATE/DDL. Commits on SQLite; autocommit on Databricks."""
    conn = get_conn()
    cur = conn.cursor()
    cur.execute(sql_text, params or {})
    if not USE_DATABRICKS:
        conn.commit()

def exec_query(sql_text: str, params: dict | None = None, one: bool = False):
    """Run SELECT and return dict rows (even on Databricks)."""
    conn = get_conn()
    cur = conn.cursor()
    cur.execute(sql_text, params or {})
    rows = [cur.fetchone()] if one else cur.fetchall()
    if not rows or rows[0] is None:
        return None if one else []
    # Map to dict using description
    cols = [d[0] for d in cur.description]
    mapped = [dict(zip(cols, r)) for r in rows]
    return mapped[0] if one else mapped

@app.teardown_appcontext
def close_conn(exc):
    conn = g.pop("conn", None)
    if conn is not None:
        conn.close()

# ========== DDL HELPERS ==========
def create_tables():
    """Create users/schools tables in the active backend."""
    if USE_DATABRICKS:
        # Ensure schema exists (no-op if exists)
        exec_nonquery(f"CREATE SCHEMA IF NOT EXISTS {DB_CATALOG}.{DB_SCHEMA}")
        # Users
        exec_nonquery(f"""
            CREATE TABLE IF NOT EXISTS {TB_USERS} (
                id BIGINT GENERATED BY DEFAULT AS IDENTITY,
                email STRING NOT NULL,
                password STRING NOT NULL,
                name STRING,
                school STRING,
                year STRING,
                major STRING,
                gpa DOUBLE,
                created_at TIMESTAMP DEFAULT CURRENT_TIMESTAMP
            ) USING DELTA
        """)
        # Schools
        exec_nonquery(f"""
            CREATE TABLE IF NOT EXISTS {TB_SCHOOLS} (
                id BIGINT,
                name STRING,
                state STRING,
                city STRING,
                sat_avg DOUBLE,
                act_avg DOUBLE,
                admission_rate DOUBLE,
                gpa_est DOUBLE
            ) USING DELTA
        """)
    else:
        # SQLite dev
        exec_nonquery("""
            CREATE TABLE IF NOT EXISTS users (
                id INTEGER PRIMARY KEY AUTOINCREMENT,
                email TEXT UNIQUE NOT NULL,
                password TEXT NOT NULL,
                name TEXT,
                school TEXT,
                year TEXT,
                major TEXT,
                gpa REAL
            )
        """)
        exec_nonquery("""
            CREATE TABLE IF NOT EXISTS schools (
                id INTEGER PRIMARY KEY,
                name TEXT,
                state TEXT,
                city TEXT,
                sat_avg REAL,
                act_avg REAL,
                admission_rate REAL,
                gpa_est REAL
            )
        """)

# ========== SCORECARD HELPERS ==========
# NOTE: request fewer fields => faster and fewer failures
SCORECARD_FIELDS = ",".join([
    "id",
    "school.name",
    "school.state",
    "school.city",
    "latest.admissions.sat_scores.average.overall",
    "latest.admissions.act_scores.midpoint.cumulative",
    "latest.admissions.admission_rate.overall",
])

def sat_to_gpa(sat):
    if not sat: return None
    # conservative normalization (SAT 1550 ~ 4.0)
    return round((float(sat) / 1525.0) * 4.0, 2)

def fetch_page(page: int, per_page: int = 40):
    resp = requests.get(
        SCORECARD_BASE,
        params={
            "api_key": SCORECARD_KEY,
            "page": page,
            "per_page": per_page,
            "fields": SCORECARD_FIELDS
        },
        timeout=15
    )
    resp.raise_for_status()
    return resp.json().get("results", [])

def upsert_school_row(row: dict):
    """Databricks MERGE for Delta; SQLite uses REPLACE INTO."""
    if USE_DATABRICKS:
        exec_nonquery(f"""
            MERGE INTO {TB_SCHOOLS} AS t
            USING (
              SELECT
                :id AS id, :name AS name, :state AS state, :city AS city,
                :sat_avg AS sat_avg, :act_avg AS act_avg,
                :admission_rate AS admission_rate, :gpa_est AS gpa_est
            ) AS s
            ON t.id = s.id
            WHEN MATCHED THEN UPDATE SET
              name = s.name, state = s.state, city = s.city,
              sat_avg = s.sat_avg, act_avg = s.act_avg,
              admission_rate = s.admission_rate, gpa_est = s.gpa_est
            WHEN NOT MATCHED THEN INSERT (id, name, state, city, sat_avg, act_avg, admission_rate, gpa_est)
            VALUES (s.id, s.name, s.state, s.city, s.sat_avg, s.act_avg, s.admission_rate, s.gpa_est)
        """, row)
    else:
        exec_nonquery("""
            INSERT OR REPLACE INTO schools
            (id, name, state, city, sat_avg, act_avg, admission_rate, gpa_est)
            VALUES (:id, :name, :state, :city, :sat_avg, :act_avg, :admission_rate, :gpa_est)
        """, row)

def seed_top_schools(limit=500, per_page=40):
    count, page = 0, 1
    while count < limit:
        results = fetch_page(page, per_page=per_page)
        if not results:
            break
        for s in results:
            sat = s.get("latest.admissions.sat_scores.average.overall")
            row = {
                "id":            s["id"],
                "name":          s.get("school.name"),
                "state":         s.get("school.state"),
                "city":          s.get("school.city"),
                "sat_avg":       sat,
                "act_avg":       s.get("latest.admissions.act_scores.midpoint.cumulative"),
                "admission_rate":s.get("latest.admissions.admission_rate.overall"),
                "gpa_est":       sat_to_gpa(sat),
            }
            upsert_school_row(row)
            count += 1
            if count >= limit:
                break
        page += 1
        time.sleep(0.2)
    print(f"Seeded {count} schools.")

# ========== CATEGORIZATION ==========
def categorize_school(user_gpa: float, school_gpa_est: float | None, t_factor: float = 0.10):
    if school_gpa_est is None or user_gpa is None:
        return "Unknown"
    diff = user_gpa - school_gpa_est
    if diff < (-t_factor / 2):
        return "Reach"
    elif abs(diff) <= t_factor:
        return "Target"
    else:
        return "Safety"

def _clip(x, lo, hi):
    return max(lo, min(hi, x))

def _phi(z):
    # Normal CDF
    return 0.5 * (1.0 + math.erf(z / math.sqrt(2.0)))

def _estimate_iqr_sat(admit_rate):
    """Estimate SAT IQR (25th–75th). More selective => narrower spread."""
    if admit_rate is None:
        return 200.0  # fallback
    # Range ~[140, 280]; broader for high admit_rate
    return _clip(140.0 + 110.0 * float(admit_rate), 120.0, 280.0)

def _estimate_iqr_gpa(admit_rate):
    """Estimate GPA IQR (25th–75th). More selective => narrower spread."""
    if admit_rate is None:
        return 0.45  # fallback
    # Range ~[0.30, 0.60]
    return _clip(0.30 + 0.30 * float(admit_rate), 0.25, 0.65)

def _gpa_to_sat(gpa, max_gpa=4.0):
    if gpa is None:
        return None
    # Inverse of your sat_to_gpa (you used 1550 → 4.0)
    return (float(gpa) / max_gpa) * 1550.0

def percentile_vs_school(user_gpa, school):
    """
    Returns a single percentile (0–100) for the user vs. a school,
    blending GPA- and SAT-based estimates when available.
    """
    if user_gpa is None:
        return None

    adm = school.get("admission_rate")
    gpa_est = school.get("gpa_est")
    sat_avg = school.get("sat_avg")

    parts = []

    # --- GPA-based percentile ---
    if gpa_est is not None:
        iqr_g = _estimate_iqr_gpa(adm)
        sigma_g = iqr_g / 1.349
        if sigma_g > 1e-6:
            z_g = (float(user_gpa) - float(gpa_est)) / sigma_g
            p_g = 100.0 * _phi(z_g)
            parts.append(("gpa", _clip(p_g, 1.0, 99.0)))

    # --- SAT-based percentile (via GPA→SAT estimate) ---
    if sat_avg is not None:
        user_sat = _gpa_to_sat(user_gpa)
        if user_sat is not None:
            iqr_s = _estimate_iqr_sat(adm)
            sigma_s = iqr_s / 1.349
            if sigma_s > 1e-6:
                z_s = (float(user_sat) - float(sat_avg)) / sigma_s
                p_s = 100.0 * _phi(z_s)
                parts.append(("sat", _clip(p_s, 1.0, 99.0)))

    if not parts:
        return None

    # Blend (favor GPA a bit if present)
    weights = {"gpa": 0.6, "sat": 0.4}
    total_w = sum(weights[k] for k, _ in parts)
    pct = sum(weights[k] * v for k, v in parts) / total_w
    return round(pct, 1)


# ========== ROUTES ==========
@app.route("/")
def index():
    return render_template("index.html", app_name=app_name)

# --- Registration (step 1)
@app.route("/register", methods=["GET", "POST"])
def register_step1():
    if request.method == "POST":
        email = request.form["email"].strip()
        password = request.form["password"]
        session["new_user_email"] = email
        session["new_user_password"] = generate_password_hash(password)
        return redirect(url_for("register_step2"))
    return render_template("register_step1.html", app_name=app_name)

# --- Registration (step 2)
@app.route("/register/details", methods=["GET", "POST"])
def register_step2():
    if "new_user_email" not in session:
        return redirect(url_for("register_step1"))

    if request.method == "POST":
        name   = request.form.get("name")
        school = request.form.get("school")
        year   = request.form.get("year")
        major  = request.form.get("major")
        gpa    = request.form.get("gpa")
        gpa    = float(gpa) if gpa not in (None, "",) else None

        try:
            exec_nonquery(f"""
                INSERT INTO {TB_USERS} (email, password, name, school, year, major, gpa)
                VALUES (:email, :password, :name, :school, :year, :major, :gpa)
            """, {
                "email": session["new_user_email"],
                "password": session["new_user_password"],
                "name": name, "school": school, "year": year, "major": major, "gpa": gpa
            })
        except Exception as e:
            flash("Email already registered or DB error.")
            return redirect(url_for("register_step1"))

        session.pop("new_user_email", None)
        session.pop("new_user_password", None)

        if major and major.lower() in ("undecided", "i don't know yet.", "i dont know yet"):
            return redirect(url_for("major_quiz"))

        flash("Account created successfully. Please log in.")
        return redirect(url_for("index"))

    majors = {
        ("STEM & Data", "Computer Science, Engineering, Math, Physics, Statistics"),
        ("Arts & Humanities", "English, Journalism, Communications, Philosophy, History"),
        ("Health & Sciences", "Biology, Chemistry, Nursing, Pre-Med, Environmental Science"),
        ("Creative & Design", "Art, Music, Graphic Design, Theater, Film, Architecture"),
        ("Social Sciences & Business", "Psychology, Sociology, Political Science, Education, Business, Economics")
    }
    return render_template("register_step2.html", app_name=app_name, majors=majors)

# --- Login
@app.route("/login", methods=["POST"])
def login():
    email = request.form["email"].strip()
    password = request.form["password"]

    user = exec_query(f"SELECT * FROM {TB_USERS} WHERE email = :email", {"email": email}, one=True)

    if user and check_password_hash(user["password"], password):
        session["user_id"] = user["id"]
        flash("Logged in successfully.")
        return redirect(url_for("dashboard"))
    else:
        flash("Invalid email or password.")
        return redirect(url_for("index"))

# --- Dashboard
@app.route("/dashboard")
def dashboard():
    if "user_id" not in session:
        return redirect(url_for("index"))

    row = exec_query(f"SELECT name FROM {TB_USERS} WHERE id = :uid", {"uid": session["user_id"]}, one=True)
    name = row["name"] if row else "Student"
    return render_template("dashboard.html", name=name)

# --- Major quiz (unchanged render/logic)
@app.route("/major_quiz", methods=["GET", "POST"])
def major_quiz():
    questions = {
        1: {"text": "What subjects or activities do you genuinely enjoy?",
            "options": {"a": "Math, logic, problem-solving",
                        "b": "Writing, reading, storytelling",
                        "c": "Science and experiments",
                        "d": "Art, music, design",
                        "e": "Helping people, teaching, volunteering"}},
        2: {"text": "Which high school classes did you look forward to most?",
            "options": {"a": "Math or Computer Science",
                        "b": "English or History",
                        "c": "Biology or Chemistry",
                        "d": "Art or Theater",
                        "e": "Business or Economics"}},
        3: {"text": "What are your strongest skills?",
            "options": {"a": "Logical reasoning, analysis",
                        "b": "Writing, communication",
                        "c": "Scientific observation, lab work",
                        "d": "Creativity, design",
                        "e": "Empathy, leadership, helping others"}},
        4: {"text": "What type of work do you prefer?",
            "options": {"a": "Numbers and Data",
                        "b": "Words and Ideas",
                        "c": "Experiments and Fieldwork",
                        "d": "Creative Projects",
                        "e": "Working With People"}},
        5: {"text": "Do you prefer structured or open-ended tasks?",
            "options": {"a": "Structured tasks with rules",
                        "b": "Open-ended, creative projects",
                        "c": "A balance of both"}},
        6: {"text": "Would you rather?",
            "options": {"a": "Work independently",
                        "b": "Collaborate in teams",
                        "c": "Lead others"}},
        7: {"text": "What kind of impact do you want your work to have?",
            "options": {"a": "Solve technical or scientific problems",
                        "b": "Inspire or inform others",
                        "c": "Heal, teach, or support people directly",
                        "d": "Shape businesses, organizations, or governments"}},
        8: {"text": "What matters more to you in a career?",
            "options": {"a": "High salary and stability",
                        "b": "Passion and fulfillment",
                        "c": "A mix of both"}},
        9: {"text": "Which careers/majors spark curiosity for you?",
            "options": {"a": "STEM (science, tech, engineering, math)",
                        "b": "Arts & Humanities",
                        "c": "Social Sciences (psych, sociology, political science)",
                        "d": "Health & Medicine",
                        "e": "Business & Economics"}},
        10: {"text": "What lifestyle do you see yourself having?",
             "options": {"a": "Fast-paced corporate or tech career",
                         "b": "Flexible creative/freelance lifestyle",
                         "c": "Steady professional (doctor, engineer, teacher)",
                         "d": "Entrepreneurial, leadership-driven",
                         "e": "Research-focused or academic"}}
    }

    categories = {
        "a": {"name": "STEM & Data",
              "majors": ["Computer Science", "Engineering", "Math", "Physics", "Statistics"]},
        "b": {"name": "Arts & Humanities",
              "majors": ["English", "Journalism", "Communications", "Philosophy", "History"]},
        "c": {"name": "Health & Sciences",
              "majors": ["Biology", "Chemistry", "Nursing", "Pre-Med", "Environmental Science"]},
        "d": {"name": "Creative & Design",
              "majors": ["Art", "Music", "Graphic Design", "Theater", "Film", "Architecture"]},
        "e": {"name": "Social Sciences & Business",
              "majors": ["Psychology", "Sociology", "Political Science", "Education", "Business", "Economics"]},
    }

    if request.method == "POST":
        responses = {}
        for qid, question in questions.items():
            chosen = request.form.get(str(qid))  # 'a', 'b', 'c'...
            if chosen:
                responses[qid] = question["options"][chosen]  # saves the text (e.g., "Math, logic, problem-solving")

        prompt = f"""
        A student answered a college major quiz. Here are their answers:
        {json.dumps(responses, indent=2)}

        Categories and associated majors:
        {json.dumps(categories, indent=2)}

        Task:
        1. Identify which category best matches the student's responses.
        2. Recommend 2-3 majors from that category.
        3. Explain why these majors fit their answers.
        4. Provide a short paragraph of encouragement for the student.

        Return JSON with:
        {{
        "category": str,
        "recommended_majors": [str],
        "reasoning": str,
        "encouragement": str
        }}
        """

        # Send to Gemini
        result = client.models.generate_content(
            model="gemini-2.5-flash",
            contents=prompt
        )

        # Parse Gemini’s JSON output
        try:
            # Cut off first seven characters for parsing (```json) and last three characters (```)
            parsed = json.loads(result.text[7:(len(result.text) - 3)])
        except:
            parsed = {"error": "AI response could not be parsed", "raw": result.text}

        return render_template("quiz_results.html", results=parsed)

    return render_template("quiz.html", questions=questions)

# --- Insights (pull from DB; no live API)
@app.route("/insights/<int:user_id>")
def insights(user_id):
    user = exec_query(f"SELECT id, email, name, school, year, major, gpa FROM {TB_USERS} WHERE id = :uid",
                      {"uid": user_id}, one=True)
    if not user:
        flash("User not found.")
        return redirect(url_for("dashboard"))

    user_gpa = user.get("gpa")
    if user_gpa is None:
        flash("Add a GPA to see insights.")
        return redirect(url_for("dashboard"))

    # Pull candidate schools
    rows = exec_query(f"""
        SELECT id, name, state, city, sat_avg, act_avg, admission_rate, gpa_est
        FROM {TB_SCHOOLS}
        WHERE sat_avg IS NOT NULL
        LIMIT 500
    """)

    buckets = {"Reach": [], "Target": [], "Safety": []}
    for s in rows:
        cat = categorize_school(user_gpa, s.get("gpa_est"))
        pct = percentile_vs_school(user_gpa, s)  # float or None

        # Map to the exact keys your template uses
        card = {
            "name": s.get("name"),
            "location": f"{(s.get('city') or '')}{', ' if s.get('city') and s.get('state') else ''}{(s.get('state') or '')}",
            "percentile": (f"{pct:.1f}%" if isinstance(pct, (int, float)) else "N/A"),
            "acceptance_rate": (f"{round(float(s['admission_rate']) * 100, 1)}%" 
                                if s.get("admission_rate") is not None else "N/A"),
            "average_sat": (int(s["sat_avg"]) if s.get("sat_avg") is not None else "N/A"),
            "logo": url_for("static", filename="school_placeholder.png"),
        }
        if cat in buckets:
            buckets[cat].append(card)

    # Sample 3/4/5 as requested
    random.seed(user_id)
    def pick(lst, n): 
        return random.sample(lst, min(n, len(lst))) if lst else []

    schools = pick(buckets["Reach"], 3) + pick(buckets["Target"], 4) + pick(buckets["Safety"], 5)

    # Category bars (numeric percent for width)
    def avg_pct(lst):
        vals = []
        for it in lst:
            try:
                vals.append(float(str(it["percentile"]).replace("%", "")))
            except:
                pass
        return round(sum(vals) / len(vals), 1) if vals else 0.0

    categories = [
        {"name": "Reach",  "percentile": avg_pct(buckets["Reach"])},
        {"name": "Target", "percentile": avg_pct(buckets["Target"])},
        {"name": "Safety", "percentile": avg_pct(buckets["Safety"])},
    ]

    # Academic snapshot
    metrics = [
        {"label": "GPA",    "value": user_gpa},
        {"label": "Year",   "value": user.get("year")   or "—"},
        {"label": "School", "value": user.get("school") or "—"},
        {"label": "Major",  "value": user.get("major")  or "—"},
    ]

    return render_template(
        "insights.html",
        app_name=app_name,
        user=user,
        categories=categories,
        metrics=metrics,
        schools=schools,
        reach=pick(buckets["Reach"], 3),
        target=pick(buckets["Target"], 4),
        safety=pick(buckets["Safety"], 5)
    )


@app.route("/logout")
def logout():
    # Clear all session data
    session.clear()
    flash("You have been logged out.")
    return redirect(url_for("index"))

# ========== MAIN ==========
if __name__ == "__main__":
    with app.app_context():
        create_tables()
        # Seed once if empty (optional)
        if not exec_query(f"SELECT 1 FROM {TB_SCHOOLS} LIMIT 1"):
             seed_top_schools(limit=1000)
    app.run(debug=True)
